
R version 4.1.0 (2021-05-18) -- "Camp Pontanezen"
Copyright (C) 2021 The R Foundation for Statistical Computing
Platform: x86_64-apple-darwin17.0 (64-bit)

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

  Natural language support but running in an English locale

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> ##########################################################
> # author: Ignacio Sarmiento-Barbieri
> ##########################################################
> 
> #Clean the workspace
> rm(list=ls())
> cat("\014")
> local({r <- getOption("repos"); r["CRAN"] <- "http://cran.r-project.org"; options(repos=r)}) #set repo
> gc() # free up memory and report memory usage
         used (Mb) gc trigger (Mb) limit (Mb) max used (Mb)
Ncells 275377 14.8     666865 35.7         NA   417476 22.3
Vcells 463384  3.6    8388608 64.0      32768  1824084 14.0
> 
> #Load Packages
> pkg<-list("tidyverse","sf","here","stars","ggplot2","lubridate")
> lapply(pkg, require, character.only=T)
Loading required package: tidyverse
── Attaching packages ─────────────────────────────────────── tidyverse 1.3.1 ──
✔ ggplot2 3.3.5     ✔ purrr   0.3.4
✔ tibble  3.1.5     ✔ dplyr   1.0.7
✔ tidyr   1.1.3     ✔ stringr 1.4.0
✔ readr   1.4.0     ✔ forcats 0.5.1
── Conflicts ────────────────────────────────────────── tidyverse_conflicts() ──
✖ dplyr::filter() masks stats::filter()
✖ dplyr::lag()    masks stats::lag()
Loading required package: sf
Linking to GEOS 3.9.1, GDAL 3.3.1, PROJ 7.2.1
Loading required package: here
here() starts at /Users/iggy/Dropbox/Research/Ethiopia/REMOTE_SENSING
Loading required package: stars
Loading required package: abind
Loading required package: lubridate

Attaching package: ‘lubridate’

The following objects are masked from ‘package:base’:

    date, intersect, setdiff, union

[[1]]
[1] TRUE

[[2]]
[1] TRUE

[[3]]
[1] TRUE

[[4]]
[1] TRUE

[[5]]
[1] TRUE

[[6]]
[1] TRUE

> rm(pkg)
> 
> #set seed
> set.seed(10101)
> 
> 
> # Read data ---------------------------------------------------------------
> poly_data<-readRDS(here("data/pilot_poligons_LU.rds"))
> #polygons<- polygons %>% filter(Name!="c010")
> 
> #read sentinel data
> sentinel<-list.files(here("data/Sentinel-2"))
> sentinel<-sentinel[grepl(".zip",sentinel)]
> sentinel<-sentinel[grepl("PBN",sentinel)]
> 
> 
> # # Check if there are already preprocessed data ----------------------------
> # preproc<-list.files(here("data/temp_bases"))
> # preproc<-preproc[grepl(".Rds",preproc)]
> # preproc<-str_remove(preproc,".Rds")
> # 
> # 
> # preproc<-paste(preproc,collapse="|")
> # sentinel<-sentinel[grepl(preproc,sentinel)==FALSE]
> 
> 
> #file_layer<-sentinel[[41]]
> create_db<-function(file_layer){
+   #This function merges and rasters to polygons and adds sentinel bands to each pixel
+   unzip(here("data/Sentinel-2",file_layer),exdir=here("data/Sentinel-2"))
+   layer_id<-str_remove(file_layer,".zip")
+   file<-str_remove(here("data/Sentinel-2",file_layer),".zip")
+   
+   sp<-list.files(paste0(file,".SAFE"),recursive = TRUE, full.names = TRUE, pattern = "*_10m.jp2$")
+   layer_star <- lapply(sp, read_stars) #read the layers
+   poly_data<-st_transform(poly_data,st_crs(layer_star[[1]])) #change CRS
+   
+   #Polygon by polygon
+   list_polygons<-split(poly_data,poly_data$Name)
+   
+   #generate area land use for each pixel
+   intersecter<-function(nm){
+     
+     poly_layer<- st_crop(layer_star[[1]], st_bbox(nm))
+     poly_layer_sf<-st_as_sf(poly_layer)
+     
+     #add centroid identifyier
+     poly_layer_sf<-poly_layer_sf %>% dplyr::mutate(pixel_id=as.character(st_centroid(geometry)),
+                                                    area_pixel=st_area(geometry))
+     
+     intersection<-suppressWarnings(st_intersection(poly_layer_sf,nm))
+     intersection<- intersection %>% mutate(area_land_use=st_area(geometry)) %>% dplyr::select(Name,pixel_id,land_use,area_pixel,area_land_use) %>% st_drop_geometry()
+     return(intersection)
+   }    
+   #list_polygons<-list_polygons[1:2]
+   polygons_ls<-lapply(list_polygons,intersecter)
+   
+   land_use_area<-do.call(rbind,polygons_ls)
+   #--------------------
+   
+   # nm<-list_polygons[[1]]
+   # x<-layer_star[[1]]
+   # generate pixel_id  
+   croper_centroid<-function(x,pgn){
+     cell<-st_crop(x,st_bbox(pgn))
+     cell<-st_as_sf(cell)
+     cell<- cell %>% dplyr::mutate(pixel_id=as.character(st_centroid(geometry)))
+     cell
+   }
+   
+   poly_layer0<-lapply(list_polygons,function(x) lapply(layer_star,croper_centroid,pgn=x))
+   
+   #x<-poly_layer0[[1]]
+   #rm(x)
+   # generate bands for each pixel
+   band_pirate<-function(x){
+     db <- suppressMessages(left_join(x[[1]], as.data.frame(x[[2]])))
+     for(i in 3:7) db <- suppressMessages(left_join(db, as.data.frame(x[[i]])))
+     
+     db<- db %>% gather(id,value,colnames(db)[grepl(".jp2",colnames(db))])
+     
+     db<- db %>% separate(col=id,into=c("layer","date","band","resolution"),sep="_",remove=TRUE) 
+     db<- db %>% mutate(version=ifelse(grepl("V",resolution),resolution,NA),
+                        version=str_remove(version,"10m.jp2."),
+                        band=ifelse(!is.na(version),paste0(band,"_",version),band),
+                        resolution=str_remove(resolution,".jp2"),
+                        resolution=str_remove(resolution,".V[1-3]")
+     ) %>% 
+       dplyr::select(-version)
+     
+     
+     db<- db %>% spread(band,value)
+     
+     db<- db %>% mutate(layer_id=layer_id) %>% relocate(layer_id)
+     return(db)
+   }
+   
+   poly_layer<-lapply(poly_layer0,band_pirate)
+   cells<-do.call(rbind,poly_layer)
+   cells <- cells %>% filter(pixel_id %in%land_use_area$pixel_id)
+   # x<- poly_layer[[1]] %>% filter(pixel_id %in%land_use_area$pixel_id)
+   # mapview::mapview(list(x,list_polygons[[1]]))
+   #cell <- cell %>% filter(pixel_id%in%land_use_area$pixel_id)
+   cells<-left_join(land_use_area,cells)
+   db<- cells %>% distinct(.keep_all = TRUE)
+   
+   
+   
+   saveRDS(db,here(paste0("data/temp_bases/",layer_id,".Rds")))  
+   #remove decrompresed file
+   
+   
+   return(db)
+ }
> 
> #dta<-create_db(sentinel[[1]])
> 
> require(parallel)
Loading required package: parallel
> detectCores(logical = FALSE)
[1] 4
> 
> 
> #sentinel<-sentinel[2:3]
> dbs<-mclapply(sentinel,create_db, mc.cores = 4)
